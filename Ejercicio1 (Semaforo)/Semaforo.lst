CCS PCM C Compiler, Version 5.093, 4770               26-ago-25 15:15

               Filename:   C:\Users\santi\OneDrive\Escritorio\EDI2\TP0\Semaforo.lst

               ROM used:   182 words (4%)
                           Largest free fragment is 2048
               RAM used:   12 (3%) at main() level
                           24 (6%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 16

0000:  MOVLP  00
0001:  GOTO   0A1
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  BTFSS  0B.5
0010:  GOTO   013
0011:  BTFSC  0B.2
0012:  GOTO   01C
0013:  MOVF   20,W
0014:  MOVWF  77
0015:  MOVF   21,W
0016:  MOVWF  78
0017:  MOVF   22,W
0018:  MOVWF  79
0019:  MOVF   23,W
001A:  MOVWF  7A
001B:  RETFIE
001C:  MOVLP  00
001D:  GOTO   01E
.................... #include <Semaforo.h>
.................... #include <16F1827.h>
.................... //////////// Standard Header file for the PIC16F1827 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F1827
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #use delay(internal=4MHz)
.................... 
.................... 
.................... 
.................... #fuses INTRC_IO   // Utilizo oscilador interno con pines RA6 y RA7 como GPIO
.................... #fuses NOMCLR     // Desactivo el MCLR
.................... #fuses NOWDT      // Desactivo el watchdog
.................... 
.................... /*****************************************************************************
....................  * Variables globales
....................  ****************************************************************************/
.................... 
.................... 
.................... int flag_segundo = 0;
.................... int max = 0;
.................... int contador_ms = 0;
.................... 
.................... /*****************************************************************************
....................  * Maquina de estado
....................  ****************************************************************************/
.................... 
.................... typedef enum {
....................     VERDE,
....................     AMARILLO,
....................     ROJO
.................... } eEstado;
.................... 
.................... eEstado estado_actual = VERDE;
.................... 
.................... void MaquinaEstado(void);
.................... 
.................... /*****************************************************************************
....................  * Funciones de Inicializacion de Perifericos
....................  ****************************************************************************/
.................... 
.................... void InitGPIO(void);
.................... void InitTimer0(void);
.................... void InicioCuentaTimer(int maximo);
.................... 
.................... 
.................... #INT_TIMER0
.................... void Timer0_ISR() {
....................    
....................    set_timer0(61);   // Reinicio el timer 0
001E:  MOVLW  3D
001F:  MOVWF  15
....................    contador_ms++;
0020:  INCF   26,F
....................    
....................    
....................    if (contador_ms >= max) { // max = Depende de la cantidad de segundos que queremos contar
0021:  MOVF   25,W
0022:  SUBWF  26,W
0023:  BTFSS  03.0
0024:  GOTO   028
....................        contador_ms = 0;
0025:  CLRF   26
....................        flag_segundo = 1; // aviso que ya pasó el tiempo deseado
0026:  MOVLW  01
0027:  MOVWF  24
....................    }
.................... 
0028:  BCF    0B.2
0029:  MOVLP  00
002A:  GOTO   013
.................... }
.................... 
.................... void main()
*
00A1:  MOVLW  6A
00A2:  MOVLB  01
00A3:  MOVWF  19
00A4:  MOVLB  00
00A5:  CLRF   24
00A6:  CLRF   25
00A7:  CLRF   26
00A8:  CLRF   27
00A9:  MOVLB  03
00AA:  CLRF   0C
00AB:  CLRF   0D
00AC:  MOVLB  02
00AD:  CLRF   12
00AE:  CLRF   11
00AF:  CLRF   14
00B0:  CLRF   13
.................... {
....................    InitGPIO();    // Inicializo el PORTA y PORTB
00B1:  MOVLB  00
00B2:  GOTO   02B
....................    InitTimer0();  // Inicializo el Timer1
00B3:  GOTO   03E
....................    while (TRUE) {
....................       MaquinaEstado();
00B4:  GOTO   051
00B5:  GOTO   0B4
....................    }
.................... }
.................... 
00B6:  SLEEP
.................... 
.................... void MaquinaEstado(void){
....................    switch (estado_actual) {
*
0051:  MOVF   27,W
0052:  XORLW  00
0053:  BTFSC  03.2
0054:  GOTO   05C
0055:  XORLW  01
0056:  BTFSC  03.2
0057:  GOTO   073
0058:  XORLW  03
0059:  BTFSC  03.2
005A:  GOTO   08A
005B:  GOTO   09F
....................       
....................       case VERDE:
....................          
....................          output_low(PIN_B1);
005C:  MOVLB  01
005D:  BCF    0D.1
005E:  MOVLB  02
005F:  BCF    0D.1
....................          output_low(PIN_B2);
0060:  MOVLB  01
0061:  BCF    0D.2
0062:  MOVLB  02
0063:  BCF    0D.2
....................          output_high(PIN_B0);
0064:  MOVLB  01
0065:  BCF    0D.0
0066:  MOVLB  02
0067:  BSF    0D.0
....................          
....................          if (flag_segundo) {        // ¿ya pasaron 5 segundos?
0068:  MOVLB  00
0069:  MOVF   24,F
006A:  BTFSC  03.2
006B:  GOTO   072
....................              flag_segundo = 0;      // limpio flag
006C:  CLRF   24
....................              InicioCuentaTimer(40);  // vuelvo a iniciar timer para el siguiente estado
006D:  MOVLW  28
006E:  MOVWF  28
006F:  CALL   04B
....................              estado_actual = AMARILLO;        
0070:  MOVLW  01
0071:  MOVWF  27
....................          }
....................          break;
0072:  GOTO   09F
....................          
....................       case AMARILLO:
....................          
....................          output_low(PIN_B0);
0073:  MOVLB  01
0074:  BCF    0D.0
0075:  MOVLB  02
0076:  BCF    0D.0
....................          output_low(PIN_B2);
0077:  MOVLB  01
0078:  BCF    0D.2
0079:  MOVLB  02
007A:  BCF    0D.2
....................          output_high(PIN_B1);
007B:  MOVLB  01
007C:  BCF    0D.1
007D:  MOVLB  02
007E:  BSF    0D.1
....................          
....................          if (flag_segundo) {        // ¿ya pasaron 2 segundos?
007F:  MOVLB  00
0080:  MOVF   24,F
0081:  BTFSC  03.2
0082:  GOTO   089
....................              flag_segundo = 0;      // limpio flag
0083:  CLRF   24
....................              InicioCuentaTimer(100);  // vuelvo a iniciar timer para el siguiente estado
0084:  MOVLW  64
0085:  MOVWF  28
0086:  CALL   04B
....................              estado_actual = ROJO;        
0087:  MOVLW  02
0088:  MOVWF  27
....................          }
....................          
....................          break;
0089:  GOTO   09F
....................          
....................       case ROJO:
....................          
....................          output_low(PIN_B0);
008A:  MOVLB  01
008B:  BCF    0D.0
008C:  MOVLB  02
008D:  BCF    0D.0
....................          output_low(PIN_B1);
008E:  MOVLB  01
008F:  BCF    0D.1
0090:  MOVLB  02
0091:  BCF    0D.1
....................          output_high(PIN_B2);
0092:  MOVLB  01
0093:  BCF    0D.2
0094:  MOVLB  02
0095:  BSF    0D.2
....................         
....................           if (flag_segundo) {        // ¿ya pasaron 5 segundos?
0096:  MOVLB  00
0097:  MOVF   24,F
0098:  BTFSC  03.2
0099:  GOTO   09F
....................              flag_segundo = 0;      // limpio flag
009A:  CLRF   24
....................              InicioCuentaTimer(100);  // vuelvo a iniciar timer para el siguiente estado
009B:  MOVLW  64
009C:  MOVWF  28
009D:  CALL   04B
....................              estado_actual = VERDE;        
009E:  CLRF   27
....................          }
....................          
....................          break;  
....................       }
009F:  MOVLP  00
00A0:  GOTO   0B5 (RETURN)
.................... }
.................... 
.................... void InitGPIO(void){
....................     set_tris_b(0b11111000);// PORTA como ENTRADA menos RA2 que es salida
*
002B:  MOVLW  F8
002C:  MOVLB  01
002D:  MOVWF  0D
.................... 
....................     output_high(PIN_B0);// VERDE
002E:  BCF    0D.0
002F:  MOVLB  02
0030:  BSF    0D.0
....................     output_low(PIN_B1);// AMARILLO
0031:  MOVLB  01
0032:  BCF    0D.1
0033:  MOVLB  02
0034:  BCF    0D.1
....................     output_low(PIN_B2);// ROJO
0035:  MOVLB  01
0036:  BCF    0D.2
0037:  MOVLB  02
0038:  BCF    0D.2
....................     
....................     max = 100;
0039:  MOVLW  64
003A:  MOVLB  00
003B:  MOVWF  25
003C:  MOVLP  00
003D:  GOTO   0B3 (RETURN)
.................... }
.................... 
.................... void InitTimer0(void){
....................    
....................     setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256); // Configuro prescaler y osc
003E:  MOVLB  01
003F:  MOVF   15,W
0040:  ANDLW  C0
0041:  IORLW  07
0042:  MOVWF  15
....................     
....................     set_timer0(0x3D);                  // Reinicio el timer
0043:  MOVLW  3D
0044:  MOVLB  00
0045:  MOVWF  15
....................     enable_interrupts(INT_TIMER0);    // Desactivo Interrupcion timer1
0046:  BSF    0B.5
....................     enable_interrupts(GLOBAL);        // Desactivo Interrupciones globales
0047:  MOVLW  C0
0048:  IORWF  0B,F
0049:  MOVLP  00
004A:  GOTO   0B4 (RETURN)
.................... }
.................... 
.................... void InicioCuentaTimer(int maximo){
.................... 
....................    max = maximo;
004B:  MOVF   28,W
004C:  MOVWF  25
.................... 
....................    set_timer0(61);                  // Reinicio el timer
004D:  MOVLW  3D
004E:  MOVWF  15
....................    contador_ms = 0;                 // Reinicio el acumulador
004F:  CLRF   26
0050:  RETURN
.................... }
.................... 

Configuration Fuses:
   Word  1: 3F84   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT PLL_SW STVREN BORV19 NODEBUG NOLVP
