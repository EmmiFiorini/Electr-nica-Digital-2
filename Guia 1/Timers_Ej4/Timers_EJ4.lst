CCS PCM C Compiler, Version 5.093, 4770               07-sept-25 22:34

               Filename:   C:\Users\santi\OneDrive\Escritorio\EDI2\TP1\Timers_EJ4.lst

               ROM used:   275 words (7%)
                           Largest free fragment is 2048
               RAM used:   11 (3%) at main() level
                           23 (6%) worst case
               Stack used: 2 locations (1 in main + 1 for interrupts)
               Stack size: 16

0000:  MOVLP  00
0001:  GOTO   0FC
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  BTFSS  0B.5
0010:  GOTO   013
0011:  BTFSC  0B.2
0012:  GOTO   01C
0013:  MOVF   20,W
0014:  MOVWF  77
0015:  MOVF   21,W
0016:  MOVWF  78
0017:  MOVF   22,W
0018:  MOVWF  79
0019:  MOVF   23,W
001A:  MOVWF  7A
001B:  RETFIE
001C:  MOVLP  00
001D:  GOTO   01E
.................... #include <Timers_EJ4.h>
.................... #include <16F1827.h>
.................... //////////// Standard Header file for the PIC16F1827 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F1827
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #use delay(internal=4MHz)
*
00E5:  MOVLW  20
00E6:  MOVWF  05
00E7:  MOVLW  07
00E8:  MOVWF  04
00E9:  MOVF   00,W
00EA:  BTFSC  03.2
00EB:  GOTO   0FA
00EC:  MOVLW  01
00ED:  MOVWF  78
00EE:  CLRF   77
00EF:  DECFSZ 77,F
00F0:  GOTO   0EF
00F1:  DECFSZ 78,F
00F2:  GOTO   0EE
00F3:  MOVLW  4A
00F4:  MOVWF  77
00F5:  DECFSZ 77,F
00F6:  GOTO   0F5
00F7:  GOTO   0F8
00F8:  DECFSZ 00,F
00F9:  GOTO   0EC
00FA:  MOVLP  00
00FB:  GOTO   112 (RETURN)
.................... 
.................... 
.................... 
.................... #fuses INTRC_IO   // Utilizo oscilador interno con pines RA6 y RA7 como GPIO
.................... #fuses NOMCLR     // Desactivo el MCLR
.................... #fuses NOWDT // Desactivo el watchdog
.................... 
.................... /*****************************************************************************
....................  * Variables globales
....................  ****************************************************************************/
.................... 
.................... int contador_ms = 0;
.................... int pata = 0;
.................... int vecesPresionado = 0;
.................... 
.................... 
.................... /*****************************************************************************
....................  * Funciones de Inicializacion de Perifericos
....................  ****************************************************************************/
.................... 
.................... void Init_GPIO();
.................... 
.................... /*****************************************************************************
.................... * Funciones
.................... ****************************************************************************/
.................... 
.................... void InitTimer0(void);
.................... void IdentificarPata(void);
.................... 
.................... #INT_TIMER0 // ACA ESCRIBO QUÉ DEBO HACER EN CADA INTERRUPCIÓN
.................... void Timer0_ISR() {
.................... 
....................     set_timer0(61);
*
001E:  MOVLW  3D
001F:  MOVWF  15
....................     contador_ms++;
0020:  INCF   24,F
....................     switch(pata) {
0021:  MOVF   25,W
0022:  XORLW  04
0023:  BTFSC  03.2
0024:  GOTO   02C
0025:  XORLW  01
0026:  BTFSC  03.2
0027:  GOTO   039
0028:  XORLW  02
0029:  BTFSC  03.2
002A:  GOTO   052
002B:  GOTO   074
....................         case 4:
....................                if(contador_ms >= 20) {  // 1 seg
002C:  MOVF   24,W
002D:  SUBLW  13
002E:  BTFSC  03.0
002F:  GOTO   038
....................                 output_low(PIN_B0); // Pasado el tiempo apagamos LED
0030:  MOVLB  01
0031:  BCF    0D.0
0032:  MOVLB  02
0033:  BCF    0D.0
....................                 contador_ms = 0;
0034:  MOVLB  00
0035:  CLRF   24
....................                 pata = 0;
0036:  CLRF   25
....................                 disable_interrupts(INT_TIMER0);
0037:  BCF    0B.5
....................                }
....................             break;
0038:  GOTO   074
....................         
....................         case 5:
....................             if(contador_ms == 20) {  // 1 seg
0039:  MOVF   24,W
003A:  SUBLW  14
003B:  BTFSS  03.2
003C:  GOTO   043
....................                 output_high(PIN_B1); // Prendemos
003D:  MOVLB  01
003E:  BCF    0D.1
003F:  MOVLB  02
0040:  BSF    0D.1
....................             }
0041:  GOTO   050
0042:  MOVLB  00
....................             else if(contador_ms >= 40) {  // 2 seg
0043:  MOVF   24,W
0044:  SUBLW  27
0045:  BTFSC  03.0
0046:  GOTO   04F
....................                 output_low(PIN_B1);  // Apagamos
0047:  MOVLB  01
0048:  BCF    0D.1
0049:  MOVLB  02
004A:  BCF    0D.1
....................                 contador_ms = 0;
004B:  MOVLB  00
004C:  CLRF   24
....................                 pata = 0;
004D:  CLRF   25
....................                 disable_interrupts(INT_TIMER0);
004E:  BCF    0B.5
004F:  MOVLB  02
....................             }
....................             break;
0050:  MOVLB  00
0051:  GOTO   074
....................         
....................         case 7:
....................             if(contador_ms >= 10) {  // 500ms
0052:  MOVF   24,W
0053:  SUBLW  09
0054:  BTFSC  03.0
0055:  GOTO   073
....................                 vecesPresionado++;
0056:  INCF   26,F
....................                 output_toggle(PIN_B2);
0057:  MOVLB  01
0058:  BCF    0D.2
0059:  MOVLW  04
005A:  MOVLB  02
005B:  XORWF  0D,F
....................                 output_toggle(PIN_B3);
005C:  MOVLB  01
005D:  BCF    0D.3
005E:  MOVLW  08
005F:  MOVLB  02
0060:  XORWF  0D,F
....................                 contador_ms = 0;
0061:  MOVLB  00
0062:  CLRF   24
....................                 if(vecesPresionado >= 10) {  // Togglea 10 veces
0063:  MOVF   26,W
0064:  SUBLW  09
0065:  BTFSC  03.0
0066:  GOTO   073
....................                     output_low(PIN_B2);
0067:  MOVLB  01
0068:  BCF    0D.2
0069:  MOVLB  02
006A:  BCF    0D.2
....................                     output_low(PIN_B3);
006B:  MOVLB  01
006C:  BCF    0D.3
006D:  MOVLB  02
006E:  BCF    0D.3
....................                     vecesPresionado = 0;
006F:  MOVLB  00
0070:  CLRF   26
....................                     pata = 0;
0071:  CLRF   25
....................                     disable_interrupts(INT_TIMER0);
0072:  BCF    0B.5
....................                 }
....................             }
....................             break;
0073:  GOTO   074
....................         default:
....................             // Nada
....................             break;
....................     }
0074:  BCF    0B.2
0075:  MOVLP  00
0076:  GOTO   013
.................... }
.................... 
.................... 
.................... void main()
*
00FC:  MOVLW  6A
00FD:  MOVLB  01
00FE:  MOVWF  19
00FF:  MOVLB  00
0100:  CLRF   24
0101:  CLRF   25
0102:  CLRF   26
0103:  MOVLB  03
0104:  CLRF   0C
0105:  CLRF   0D
0106:  MOVLB  02
0107:  CLRF   12
0108:  CLRF   11
0109:  CLRF   14
010A:  CLRF   13
.................... {
.................... 
.................... Init_GPIO();
010B:  MOVLB  00
010C:  GOTO   077
.................... InitTimer0();
010D:  GOTO   09D
.................... 
....................    while(TRUE)
....................    {
....................     IdentificarPata();
010E:  GOTO   0AA
....................     delay_ms(20); //Hasta tener el anti rebote
010F:  MOVLW  14
0110:  MOVWF  27
0111:  GOTO   0E5
0112:  GOTO   10E
....................    }
.................... 
.................... }
.................... 
0113:  SLEEP
.................... void Init_GPIO()
.................... {
.................... /* SETEAMOS LOS PINES PB0-3 y PA0-3 COMO SALIDA */
....................    set_tris_b(0b11110000);
*
0077:  MOVLW  F0
0078:  MOVLB  01
0079:  MOVWF  0D
....................    set_tris_a(0b11110000);
007A:  MOVWF  0C
.................... 
....................    output_low(PIN_B0);
007B:  BCF    0D.0
007C:  MOVLB  02
007D:  BCF    0D.0
....................    output_low(PIN_B1);
007E:  MOVLB  01
007F:  BCF    0D.1
0080:  MOVLB  02
0081:  BCF    0D.1
....................    output_low(PIN_B2);
0082:  MOVLB  01
0083:  BCF    0D.2
0084:  MOVLB  02
0085:  BCF    0D.2
....................    output_low(PIN_B3);
0086:  MOVLB  01
0087:  BCF    0D.3
0088:  MOVLB  02
0089:  BCF    0D.3
....................    
....................    output_low(PIN_A0);
008A:  MOVLB  01
008B:  BCF    0C.0
008C:  MOVLB  02
008D:  BCF    0C.0
....................    output_low(PIN_A1);
008E:  MOVLB  01
008F:  BCF    0C.1
0090:  MOVLB  02
0091:  BCF    0C.1
....................    output_low(PIN_A2);
0092:  MOVLB  01
0093:  BCF    0C.2
0094:  MOVLB  02
0095:  BCF    0C.2
....................    output_low(PIN_A3);
0096:  MOVLB  01
0097:  BCF    0C.3
0098:  MOVLB  02
0099:  BCF    0C.3
009A:  MOVLP  00
009B:  MOVLB  00
009C:  GOTO   10D (RETURN)
.................... }
.................... 
.................... void InitTimer0(void){
....................    
....................     setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256); // Configuro prescaler
009D:  MOVLB  01
009E:  MOVF   15,W
009F:  ANDLW  C0
00A0:  IORLW  07
00A1:  MOVWF  15
....................     
....................     set_timer0(61);                  // Reinicio el timer --> Interrupciones cada 50ms
00A2:  MOVLW  3D
00A3:  MOVLB  00
00A4:  MOVWF  15
....................     enable_interrupts(INT_TIMER0);    // Activo Interrupcion timer0
00A5:  BSF    0B.5
....................     enable_interrupts(GLOBAL);        // Activo Interrupciones globales
00A6:  MOVLW  C0
00A7:  IORWF  0B,F
00A8:  MOVLP  00
00A9:  GOTO   10E (RETURN)
.................... }
.................... 
.................... void IdentificarPata() {
.................... 
....................    if(!input(PIN_B4) && pata == 0) {
00AA:  MOVLB  01
00AB:  BSF    0D.4
00AC:  MOVLB  00
00AD:  BTFSC  0D.4
00AE:  GOTO   0BD
00AF:  MOVF   25,F
00B0:  BTFSS  03.2
00B1:  GOTO   0BD
....................      pata = 4;
00B2:  MOVLW  04
00B3:  MOVWF  25
....................      output_high(PIN_B0);
00B4:  MOVLB  01
00B5:  BCF    0D.0
00B6:  MOVLB  02
00B7:  BSF    0D.0
....................      set_timer0(61);                   // arranco el conteo
00B8:  MOVLW  3D
00B9:  MOVLB  00
00BA:  MOVWF  15
....................      enable_interrupts(INT_TIMER0);    // habilito interrupción recien ahora
00BB:  BSF    0B.5
....................    } 
00BC:  GOTO   0E3
....................    else if(!input(PIN_B5) && pata == 0) {
00BD:  MOVLB  01
00BE:  BSF    0D.5
00BF:  MOVLB  00
00C0:  BTFSC  0D.5
00C1:  GOTO   0CB
00C2:  MOVF   25,F
00C3:  BTFSS  03.2
00C4:  GOTO   0CB
....................      pata = 5;
00C5:  MOVLW  05
00C6:  MOVWF  25
....................      set_timer0(61);
00C7:  MOVLW  3D
00C8:  MOVWF  15
....................      enable_interrupts(INT_TIMER0);
00C9:  BSF    0B.5
....................    }
00CA:  GOTO   0E3
....................    else if(!input(PIN_B6) && pata == 0) {
00CB:  MOVLB  01
00CC:  BSF    0D.6
00CD:  MOVLB  00
00CE:  BTFSC  0D.6
00CF:  GOTO   0D6
00D0:  MOVF   25,F
00D1:  BTFSS  03.2
00D2:  GOTO   0D6
....................      pata = 6;
00D3:  MOVLW  06
00D4:  MOVWF  25
....................    }
00D5:  GOTO   0E3
....................    else if(!input(PIN_B7) && pata == 0) {
00D6:  MOVLB  01
00D7:  BSF    0D.7
00D8:  MOVLB  00
00D9:  BTFSC  0D.7
00DA:  GOTO   0E3
00DB:  MOVF   25,F
00DC:  BTFSS  03.2
00DD:  GOTO   0E3
....................      pata = 7;
00DE:  MOVLW  07
00DF:  MOVWF  25
....................      set_timer0(61);
00E0:  MOVLW  3D
00E1:  MOVWF  15
....................      enable_interrupts(INT_TIMER0);
00E2:  BSF    0B.5
....................    }
00E3:  MOVLP  00
00E4:  GOTO   10F (RETURN)
.................... }

Configuration Fuses:
   Word  1: 3F84   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT PLL_SW STVREN BORV19 NODEBUG NOLVP
