#include <Ejercicio5.h>

#fuses INTRC_IO   // Oscilador interno con pines RA6 y RA7 como GPIO
#fuses NOMCLR     // Desactivo el MCLR
#fuses NOWDT      // Desactivo el watchdog


/*****************************************************************************
 * LCD
 ****************************************************************************/

#define LCD_ENABLE_PIN  PIN_A0
#define LCD_RS_PIN      PIN_A1
#define LCD_RW_PIN      PIN_A2 // CONECTADO A GND SI NO LO USAMOS
#define LCD_DATA4       PIN_A4
#define LCD_DATA5       PIN_A3
#define LCD_DATA6       PIN_A6
#define LCD_DATA7       PIN_A7
#include <lcd.c>

#define use_portb_kbd TRUE //defino el portb como donde va el teclado
#include <kbd.c>

/*****************************************************************************
 * Funciones de Inicializacion de Perifericos
 ****************************************************************************/
 
void Init_GPIO(void);
void Init_ADC(void);
void InitTimer0(void);

/*****************************************************************************
* Estados
****************************************************************************/
typedef enum {
    INICIO,            
    ESPERA_TECLA,      
    CLAVE_CORRECTA,   
    CLAVE_INCORRECTA   
} eEstado;

eEstado estado_actual = INICIO;

/*****************************************************************************
* Funciones
****************************************************************************/

void maquina(void);
int comparadorcontra(void);

/*****************************************************************************
* Variables globales
****************************************************************************/

int contador_ms = 0;
int flag_tiempo_cumplido = 0; // Aviso de tiempo cumplido

char tecla;
const char contra_real[3] = {'2','5','3'}; // contraseña 
int cont_digitos = 0; 
int cont_digitos_correctos = 0; 

/*****************************************************************************
* Interrupciones
****************************************************************************/

#INT_TIMER0 // ACA ESCRIBO QUÉ DEBO HACER EN CADA INTERRUPCIÓN
void Timer0_ISR() {
    set_timer0(61); // 50ms
    contador_ms++;
  
    if(estado_actual == CLAVE_CORRECTA || estado_actual == CLAVE_INCORRECTA) {
          if(contador_ms >= 40) { // 2 s
              contador_ms = 0;
              flag_tiempo_cumplido = 1; 
          }
      }
    
}

/*****************************************************************************
* Main
****************************************************************************/
void main()
{

   Init_GPIO();
   lcd_init(); //inicializo el led
   kbd_init();//inicializo el teclado
   InitTimer0();
   while(TRUE) {
      maquina();
   }

}

void maquina(void) {
    
    switch(estado_actual) {
        
        case INICIO:
          lcd_putc("\fIngrese Clave:");
          lcd_gotoxy(1,2);
      
          cont_digitos = 0;
          cont_digitos_correctos = 0;
      
          contador_ms = 0;
          flag_tiempo_cumplido = 0;
      
          estado_actual = ESPERA_TECLA;
          break;

        case ESPERA_TECLA:
             tecla = kbd_getc();
         
             if(tecla != 0) {
                 lcd_putc('*');   // mostrar asterisco
                 // comparo la tecla con el dígito real
                 if (tecla == contra_real[cont_digitos]) {
                     cont_digitos_correctos++;
                 }
                 cont_digitos++;  // siempre incremento       
                 if(cont_digitos == 3) {
                     contador_ms = 0;
                     if(cont_digitos_correctos == 3)
                         estado_actual = CLAVE_CORRECTA;
                     else
                         estado_actual = CLAVE_INCORRECTA;
                 }
             }
             break;
             
       case CLAVE_CORRECTA:
             lcd_putc("Correcta");
         
             if(flag_tiempo_cumplido == 1) {
                 estado_actual = INICIO;
             }
             break;

        case CLAVE_INCORRECTA:
            lcd_putc("Incorrecta");
         
             if(flag_tiempo_cumplido == 1) {
                 estado_actual = INICIO;
             }
             break;
            
        default:
            estado_actual = INICIO;
            break;
    }
}
void InitTimer0(void) {

    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256); // Configuro prescaler
    set_timer0(61);                  // Reinicio el timer --> Interrupciones cada 50ms
    enable_interrupts(INT_TIMER0);    // Activo Interrupcion timer0
    
}

void Init_GPIO()
{

   set_tris_b(0b00001111); // RB0, RB1, RB2 y RB3 filas del teclado, entrada  // RB4, RB6, RB7 columnas, salidas
   set_tris_a(0b00000000); // TODO COMO SALIDA EN ESTADO BAJO 

   enable_interrupts(GLOBAL);
}
