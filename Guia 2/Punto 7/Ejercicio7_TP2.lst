CCS PCM C Compiler, Version 5.093, 4770               21-nov.-25 13:59

               Filename:   C:\Users\MPF\Desktop\Git\Electr-nica-Digital-2\Guia 2\Punto 7\Ejercicio7_TP2.lst

               ROM used:   133 words (3%)
                           Largest free fragment is 2048
               RAM used:   11 (3%) at main() level
                           22 (6%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 16

0000:  MOVLP  00
0001:  GOTO   06F
0002:  NOP
*
0004:  CLRF   03
0005:  MOVLP  00
0006:  MOVLB  00
0007:  MOVF   77,W
0008:  MOVWF  20
0009:  MOVF   78,W
000A:  MOVWF  21
000B:  MOVF   79,W
000C:  MOVWF  22
000D:  MOVF   7A,W
000E:  MOVWF  23
000F:  CLRF   05
0010:  MOVLW  91
0011:  MOVWF  04
0012:  BTFSS  00.6
0013:  GOTO   016
0014:  BTFSC  11.6
0015:  GOTO   01F
0016:  MOVF   20,W
0017:  MOVWF  77
0018:  MOVF   21,W
0019:  MOVWF  78
001A:  MOVF   22,W
001B:  MOVWF  79
001C:  MOVF   23,W
001D:  MOVWF  7A
001E:  RETFIE
001F:  MOVLP  00
0020:  GOTO   021
.................... #include <Ejercicio7_TP2.h>
.................... #include <16F1827.h>
.................... //////////// Standard Header file for the PIC16F1827 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F1827
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #use delay(internal=4MHz)
.................... 
.................... 
.................... 
.................... #fuses INTRC_IO   // Oscilador interno con pines RA6 y RA7 como GPIO
.................... #fuses NOMCLR     // Desactivo el MCLR
.................... #fuses NOWDT      // Desactivo el watchdog     
.................... #use delay(clock=4000000) 
.................... 
.................... typedef unsigned int8 t_dac_value; 
.................... 
.................... // Prototipos
.................... void Init_GPIO(void);
.................... void Init_ADC(void);
.................... void Init_DAC(void);
.................... 
.................... // Variables globales
.................... unsigned int16 resultado_adc = 0;
.................... t_dac_value resultado_dac = 0; 
.................... 
.................... /*****************************************************************************
.................... * Interrupciones (ISR)
.................... ****************************************************************************/
.................... #INT_AD
.................... void ISR_ADC(void) {
....................     // 1. Leo conversión (10 bits)
....................     resultado_adc = read_adc(ADC_READ_ONLY); 
0021:  MOVLW  11
0022:  MOVWF  77
0023:  MOVLB  01
0024:  BTFSS  1D.1
0025:  GOTO   028
0026:  DECFSZ 77,F
0027:  GOTO   024
0028:  MOVF   1B,W
0029:  MOVWF  78
002A:  MOVF   1C,W
002B:  MOVLB  00
002C:  MOVWF  25
002D:  MOVF   78,W
002E:  MOVWF  24
....................     
....................     // 2. Escalado de 10 bits a 5 bits (1024 niveles -> 32 niveles)
....................     resultado_dac = (t_dac_value)(resultado_adc >> 5); 
002F:  RRF    25,W
0030:  MOVWF  7A
0031:  RRF    24,W
0032:  MOVWF  79
0033:  RRF    7A,F
0034:  RRF    79,F
0035:  RRF    7A,F
0036:  RRF    79,F
0037:  RRF    7A,F
0038:  RRF    79,F
0039:  RRF    7A,F
003A:  RRF    79,F
003B:  MOVLW  07
003C:  ANDWF  7A,F
003D:  MOVF   79,W
003E:  MOVWF  26
.................... 
....................     // 3. ENVIAR VALOR AL MÓDULO DAC INTERNO
....................     dac_write(resultado_dac); 
003F:  MOVF   26,W
0040:  MOVLB  02
0041:  MOVWF  19
....................     
....................     // 4. Iniciar la siguiente conversión inmediatamente (muestreo periódico)
....................     read_adc(ADC_START_ONLY); 
0042:  MOVLB  01
0043:  BSF    1D.1
0044:  MOVLB  00
0045:  BCF    11.6
0046:  MOVLP  00
0047:  GOTO   016
.................... }
.................... 
.................... 
.................... void main()
*
006F:  MOVLW  6A
0070:  MOVLB  01
0071:  MOVWF  19
0072:  MOVLB  00
0073:  CLRF   25
0074:  CLRF   24
0075:  CLRF   26
0076:  MOVLB  03
0077:  CLRF   0C
0078:  CLRF   0D
0079:  MOVLB  02
007A:  CLRF   12
007B:  CLRF   11
007C:  CLRF   14
007D:  CLRF   13
.................... {
....................     Init_GPIO();
007E:  MOVLB  00
007F:  GOTO   048
....................     Init_ADC();
0080:  GOTO   059
....................     Init_DAC();
0081:  GOTO   069
.................... 
....................     // *** CORRECCIÓN CRÍTICA: PULSO INICIAL DEL ADC ***
....................     read_adc(ADC_START_ONLY); 
0082:  MOVLB  01
0083:  BSF    1D.1
.................... 
....................     // El bucle principal solo espera el flujo de interrupciones
....................     while(TRUE)
....................     {
0084:  GOTO   084
....................         // El proceso está autocontenido en la ISR.
....................         // Se puede usar SLEEP para ahorro de energía aquí.
....................     }
.................... }
.................... void Init_GPIO()
0085:  SLEEP
.................... {
....................     // Usamos esta directiva para configurar RA0 (AN0) como analógico (entrada), 
....................     // y el resto de los pines (RA1, RA2, etc.) como digitales, 
....................     // y establecemos las referencias a VDD/VSS.
....................     setup_adc_ports(sAN0 | VSS_VDD); // <--- CORRECCIÓN CLAVE
*
0048:  MOVLB  01
0049:  BCF    1E.0
004A:  BCF    1E.1
004B:  BCF    1E.2
004C:  MOVLW  01
004D:  MOVLB  03
004E:  MOVWF  0C
004F:  MOVLW  00
0050:  MOVWF  0D
....................     
....................     // set_tris_a: RA0 (AN0) es entrada (1), RA2 (DACOUT) es salida (0).
....................     set_tris_a(0b00000001); 
0051:  MOVLW  01
0052:  MOVLB  01
0053:  MOVWF  0C
....................     
....................     // ... (rest of Init_GPIO) ...
....................     enable_interrupts(GLOBAL);
0054:  MOVLW  C0
0055:  IORWF  0B,F
0056:  MOVLP  00
0057:  MOVLB  00
0058:  GOTO   080 (RETURN)
.................... }
.................... // ...
.................... void Init_ADC() {
....................     setup_adc(ADC_CLOCK_INTERNAL); 
0059:  MOVLB  01
005A:  BSF    1E.4
005B:  BSF    1E.5
005C:  BCF    1E.6
005D:  BSF    1E.7
005E:  BSF    1D.0
....................     set_adc_channel(0); // Selecciona AN0
005F:  MOVLW  00
0060:  MOVWF  78
0061:  MOVF   1D,W
0062:  ANDLW  83
0063:  IORWF  78,W
0064:  MOVWF  1D
....................     enable_interrupts(INT_AD); 
0065:  BSF    11.6
0066:  MOVLP  00
0067:  MOVLB  00
0068:  GOTO   081 (RETURN)
.................... }
.................... 
.................... void Init_DAC(void) {
....................     setup_dac(DAC_VSS_VDD | DAC_OUTPUT); 
0069:  MOVLW  A0
006A:  MOVLB  02
006B:  MOVWF  18
006C:  MOVLP  00
006D:  MOVLB  00
006E:  GOTO   082 (RETURN)
.................... }

Configuration Fuses:
   Word  1: 3F84   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT PLL_SW STVREN BORV19 NODEBUG NOLVP
