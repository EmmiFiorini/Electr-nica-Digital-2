CCS PCM C Compiler, Version 5.093, 4770               03-nov-25 18:34

               Filename:   C:\Users\santi\OneDrive\Documentos\EDI2_Grupo_11\Electr-nica-Digital-2\TP FINALL\TP_Final_Grupo11.lst

               ROM used:   479 words (12%)
                           Largest free fragment is 2048
               RAM used:   7 (2%) at main() level
                           25 (7%) worst case
               Stack used: 1 locations
               Stack size: 16

0000:  MOVLP  00
0001:  GOTO   1AD
0002:  NOP
.................... #include <TP_Final_Grupo11.h>
.................... #include <16F1827.h>
.................... //////////// Standard Header file for the PIC16F1827 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F1827
0003:  BRW
0004:  RETLW  3F
0005:  RETLW  06
0006:  RETLW  5B
0007:  RETLW  4F
0008:  RETLW  66
0009:  RETLW  6D
000A:  RETLW  7D
000B:  RETLW  07
000C:  RETLW  7F
000D:  RETLW  67
000E:  BRW
000F:  RETLW  31
0010:  RETLW  32
0011:  RETLW  33
0012:  RETLW  34
0013:  RETLW  35
0014:  RETLW  36
0015:  RETLW  37
0016:  RETLW  38
0017:  RETLW  39
0018:  RETLW  2A
0019:  RETLW  30
001A:  RETLW  23
001B:  BRW
001C:  RETLW  68
001D:  RETLW  69
001E:  RETLW  6A
001F:  RETLW  6B
0020:  BRW
0021:  RETLW  6C
0022:  RETLW  6E
0023:  RETLW  6F
*
0049:  MOVF   26,W
004A:  ANDLW  07
004B:  MOVWF  77
004C:  RRF    26,W
004D:  MOVWF  78
004E:  RRF    78,F
004F:  RRF    78,F
0050:  MOVLW  1F
0051:  ANDWF  78,F
0052:  MOVF   78,W
0053:  ADDWF  28,W
0054:  MOVWF  04
0055:  MOVLW  00
0056:  ADDWFC 29,W
0057:  MOVWF  05
0058:  CLRF   78
0059:  INCF   78,F
005A:  INCF   77,F
005B:  GOTO   05D
005C:  RLF    78,F
005D:  DECFSZ 77,F
005E:  GOTO   05C
005F:  MOVF   27,F
0060:  BTFSC  03.2
0061:  GOTO   065
0062:  MOVF   78,W
0063:  IORWF  00,F
0064:  GOTO   068
0065:  COMF   78,F
0066:  MOVF   78,W
0067:  ANDWF  00,F
0068:  RETURN
0069:  MOVF   26,W
006A:  ANDLW  07
006B:  MOVWF  77
006C:  RRF    26,W
006D:  MOVWF  78
006E:  RRF    78,F
006F:  RRF    78,F
0070:  MOVLW  1F
0071:  ANDWF  78,F
0072:  MOVF   78,W
0073:  ADDWF  27,W
0074:  MOVWF  04
0075:  MOVLW  00
0076:  ADDWFC 28,W
0077:  MOVWF  05
0078:  MOVF   00,W
0079:  MOVWF  78
007A:  INCF   77,F
007B:  GOTO   07D
007C:  RRF    78,F
007D:  DECFSZ 77,F
007E:  GOTO   07C
007F:  MOVLW  01
0080:  ANDWF  78,F
0081:  RETURN
*
00F2:  CLRF   77
00F3:  CLRF   78
00F4:  MOVF   25,W
00F5:  BCF    03.0
00F6:  BTFSC  26.0
00F7:  ADDWF  77,F
00F8:  RRF    77,F
00F9:  RRF    78,F
00FA:  BTFSC  26.1
00FB:  ADDWF  77,F
00FC:  RRF    77,F
00FD:  RRF    78,F
00FE:  BTFSC  26.2
00FF:  ADDWF  77,F
0100:  RRF    77,F
0101:  RRF    78,F
0102:  BTFSC  26.3
0103:  ADDWF  77,F
0104:  RRF    77,F
0105:  RRF    78,F
0106:  BTFSC  26.4
0107:  ADDWF  77,F
0108:  RRF    77,F
0109:  RRF    78,F
010A:  BTFSC  26.5
010B:  ADDWF  77,F
010C:  RRF    77,F
010D:  RRF    78,F
010E:  BTFSC  26.6
010F:  ADDWF  77,F
0110:  RRF    77,F
0111:  RRF    78,F
0112:  BTFSC  26.7
0113:  ADDWF  77,F
0114:  RRF    77,F
0115:  RRF    78,F
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #use delay(internal=4MHz)
*
0082:  MOVLW  20
0083:  MOVWF  05
0084:  MOVLW  05
0085:  MOVWF  04
0086:  MOVF   00,W
0087:  BTFSC  03.2
0088:  GOTO   097
0089:  MOVLW  01
008A:  MOVWF  78
008B:  CLRF   77
008C:  DECFSZ 77,F
008D:  GOTO   08C
008E:  DECFSZ 78,F
008F:  GOTO   08B
0090:  MOVLW  4A
0091:  MOVWF  77
0092:  DECFSZ 77,F
0093:  GOTO   092
0094:  GOTO   095
0095:  DECFSZ 00,F
0096:  GOTO   089
0097:  RETURN
.................... 
.................... 
.................... 
.................... #use RS232(BAUD = 9600, XMIT = PIN_B5, BITS = 8, PARITY = N, STOP = 1)
*
014B:  MOVLB  01
014C:  BCF    0D.5
014D:  MOVLB  02
014E:  BCF    0D.5
014F:  MOVLW  08
0150:  MOVWF  78
0151:  GOTO   152
0152:  NOP
0153:  BSF    78.7
0154:  GOTO   165
0155:  BCF    78.7
0156:  MOVLB  00
0157:  RRF    22,F
0158:  MOVLB  02
0159:  BTFSC  03.0
015A:  BSF    0D.5
015B:  BTFSS  03.0
015C:  BCF    0D.5
015D:  BSF    78.6
015E:  GOTO   165
015F:  BCF    78.6
0160:  DECFSZ 78,F
0161:  GOTO   156
0162:  GOTO   163
0163:  NOP
0164:  BSF    0D.5
0165:  MOVLW  1B
0166:  MOVWF  04
0167:  DECFSZ 04,F
0168:  GOTO   167
0169:  GOTO   16A
016A:  NOP
016B:  BTFSC  78.7
016C:  GOTO   155
016D:  BTFSC  78.6
016E:  GOTO   15F
016F:  MOVLB  00
0170:  RETURN
.................... 
.................... #fuses INTRC_IO   // Oscilador interno con pines RA6 y RA7 como GPIO
.................... #fuses NOMCLR     // Desactivo el MCLR
.................... #fuses NOWDT      // Desactivo el watchdog
.................... 
.................... //CATODO COMUN:
.................... Byte CONST display[10]= {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x67}; //npn
.................... 
.................... /*****************************************************************************
....................  * Funciones de Inicializacion
....................  ****************************************************************************/
....................  
.................... void Init_GPIO(void);
.................... void Init_Keypad(void);
.................... void decharabin(void);
.................... 
.................... /*****************************************************************************
.................... * Variables globales
.................... ****************************************************************************/
.................... 
.................... const char keymap[4][3] = {
....................   {'1','2','3'},
....................   {'4','5','6'},
....................   {'7','8','9'},
....................   {'*','0','#'}
.................... };
.................... 
.................... char tecla = ' ';
.................... int8 teclabin = 00000000; //inicializo en 0
.................... 
.................... /*****************************************************************************
.................... * Funciones
.................... ****************************************************************************/
.................... 
.................... void maquina(void);
.................... char getKey(void);
.................... 
.................... /*****************************************************************************
.................... * Interrupciones
.................... ****************************************************************************/
.................... 
.................... void main()
*
01AD:  MOVLW  6A
01AE:  MOVLB  01
01AF:  MOVWF  19
01B0:  BCF    0D.5
01B1:  MOVLB  02
01B2:  BSF    0D.5
01B3:  MOVLW  20
01B4:  MOVLB  00
01B5:  MOVWF  20
01B6:  CLRF   21
01B7:  MOVLB  03
01B8:  CLRF   0C
01B9:  CLRF   0D
01BA:  MOVLB  02
01BB:  CLRF   12
01BC:  CLRF   11
01BD:  CLRF   14
01BE:  CLRF   13
.................... {
....................    Init_GPIO();
01BF:  MOVLB  00
01C0:  GOTO   024
....................    Init_Keypad();
01C1:  GOTO   02E
....................    
....................    while(TRUE)
....................    {
.................... 
....................    tecla = getKey();
01C2:  GOTO   098
01C3:  MOVF   78,W
01C4:  MOVWF  20
....................    
....................    if(tecla != 'f') {
01C5:  MOVF   20,W
01C6:  SUBLW  66
01C7:  BTFSC  03.2
01C8:  GOTO   1DD
....................          printf("<%c>", tecla);
01C9:  MOVLW  3C
01CA:  MOVWF  22
01CB:  CALL   14B
01CC:  MOVF   20,W
01CD:  MOVWF  22
01CE:  CALL   14B
01CF:  MOVLW  3E
01D0:  MOVWF  22
01D1:  CALL   14B
....................          decharabin();
01D2:  GOTO   171
....................          output_a(display[teclabin]);
01D3:  MOVF   21,W
01D4:  CALL   003
01D5:  MOVWF  22
01D6:  MOVLB  01
01D7:  CLRF   0C
01D8:  MOVLB  00
01D9:  MOVF   22,W
01DA:  MOVLB  02
01DB:  MOVWF  0C
01DC:  MOVLB  00
....................       } 
01DD:  GOTO   1C2
....................    }
.................... }
.................... 
01DE:  SLEEP
.................... void decharabin(){//funcion que cambia de char a binario
....................    if(tecla == '0')
*
0171:  MOVF   20,W
0172:  SUBLW  30
0173:  BTFSS  03.2
0174:  GOTO   177
....................       teclabin=  1111110; //escribo el 0
0175:  MOVLW  46
0176:  MOVWF  21
....................    if (tecla == '1')
0177:  MOVF   20,W
0178:  SUBLW  31
0179:  BTFSC  03.2
....................       teclabin=  0110000; //escribo el 1
017A:  CLRF   21
....................    if (tecla == '2')
017B:  MOVF   20,W
017C:  SUBLW  32
017D:  BTFSS  03.2
017E:  GOTO   181
....................       teclabin=  1101101; //escribo el 2
017F:  MOVLW  2D
0180:  MOVWF  21
....................    if (tecla == '3')
0181:  MOVF   20,W
0182:  SUBLW  33
0183:  BTFSS  03.2
0184:  GOTO   187
....................       teclabin=  1111001; //escribo el 3
0185:  MOVLW  D9
0186:  MOVWF  21
....................    if (tecla == '4')
0187:  MOVF   20,W
0188:  SUBLW  34
0189:  BTFSS  03.2
018A:  GOTO   18D
....................       teclabin=  0110011; //escribo el 4
018B:  MOVLW  09
018C:  MOVWF  21
....................    if (tecla == '5')
018D:  MOVF   20,W
018E:  SUBLW  35
018F:  BTFSS  03.2
0190:  GOTO   193
....................       teclabin=  1011011; //escribo el 5
0191:  MOVLW  43
0192:  MOVWF  21
....................    if (tecla == '6')
0193:  MOVF   20,W
0194:  SUBLW  36
0195:  BTFSS  03.2
0196:  GOTO   199
....................       teclabin=  0011111; //escribo el 6
0197:  MOVLW  49
0198:  MOVWF  21
....................    if (tecla == '7')
0199:  MOVF   20,W
019A:  SUBLW  37
019B:  BTFSS  03.2
019C:  GOTO   19F
....................       teclabin=  1110000; //escribo el 7
019D:  MOVLW  F0
019E:  MOVWF  21
....................    if (tecla == '8')
019F:  MOVF   20,W
01A0:  SUBLW  38
01A1:  BTFSS  03.2
01A2:  GOTO   1A5
....................       teclabin=  1111111; //escribo el 8
01A3:  MOVLW  47
01A4:  MOVWF  21
....................    if (tecla == '9')
01A5:  MOVF   20,W
01A6:  SUBLW  39
01A7:  BTFSS  03.2
01A8:  GOTO   1AB
....................       teclabin=  1110011; //escribo el 9
01A9:  MOVLW  FB
01AA:  MOVWF  21
01AB:  MOVLP  00
01AC:  GOTO   1D3 (RETURN)
.................... }
.................... 
.................... void maquina(void) {
.................... }
.................... 
.................... void Init_GPIO(void){ 
....................    
....................    set_tris_a(0b00000000);
*
0024:  MOVLW  00
0025:  MOVLB  01
0026:  MOVWF  0C
....................    set_tris_b(0b11010000); // RB0, RB1, RB2 y RB3 filas del teclado, entrada
0027:  MOVLW  D0
0028:  MOVWF  0D
....................                            // RB4, RB6, RB7 columnas, salidas
....................    
....................    enable_interrupts(GLOBAL);
0029:  MOVLW  C0
002A:  IORWF  0B,F
002B:  MOVLP  00
002C:  MOVLB  00
002D:  GOTO   1C1 (RETURN)
.................... }
.................... 
.................... void Init_Keypad(void){
....................    
....................    setup_adc_ports(NO_ANALOGS); // desactiva funciones analógicas en los pines si aplica
002E:  MOVLB  01
002F:  BCF    1E.0
0030:  BCF    1E.1
0031:  BCF    1E.2
0032:  MOVLW  00
0033:  MOVLB  03
0034:  MOVWF  0C
0035:  MOVWF  0D
.................... 
....................    // Se dejan las filas inicialmente en HIGH (no activas)
....................    output_high(PIN_B0);
0036:  MOVLB  01
0037:  BCF    0D.0
0038:  MOVLB  02
0039:  BSF    0D.0
....................    output_high(PIN_B1);
003A:  MOVLB  01
003B:  BCF    0D.1
003C:  MOVLB  02
003D:  BSF    0D.1
....................    output_high(PIN_B2);
003E:  MOVLB  01
003F:  BCF    0D.2
0040:  MOVLB  02
0041:  BSF    0D.2
....................    output_high(PIN_B3);
0042:  MOVLB  01
0043:  BCF    0D.3
0044:  MOVLB  02
0045:  BSF    0D.3
0046:  MOVLP  00
0047:  MOVLB  00
0048:  GOTO   1C2 (RETURN)
.................... }
.................... 
.................... char getKey(void){
*
0098:  MOVLW  66
0099:  MOVWF  24
.................... 
....................    const unsigned char pines_filas[4] = {PIN_B0, PIN_B1, PIN_B2, PIN_B3};
....................    const unsigned char pines_col[3] = {PIN_B4, PIN_B6, PIN_B7};
....................    int f, c;
....................    char result = 'f';
....................    
....................    for(f = 0; f < 4; f++) {
009A:  CLRF   22
009B:  MOVF   22,W
009C:  SUBLW  03
009D:  BTFSS  03.0
009E:  GOTO   147
....................       // Poner todas las filas en HIGH
....................       output_high(PIN_B0);
009F:  MOVLB  01
00A0:  BCF    0D.0
00A1:  MOVLB  02
00A2:  BSF    0D.0
....................       output_high(PIN_B1);
00A3:  MOVLB  01
00A4:  BCF    0D.1
00A5:  MOVLB  02
00A6:  BSF    0D.1
....................       output_high(PIN_B2);
00A7:  MOVLB  01
00A8:  BCF    0D.2
00A9:  MOVLB  02
00AA:  BSF    0D.2
....................       output_high(PIN_B3);
00AB:  MOVLB  01
00AC:  BCF    0D.3
00AD:  MOVLB  02
00AE:  BSF    0D.3
.................... 
....................       // Activar la fila r (tirarla a LOW)
....................       output_low(pines_filas[f]);
00AF:  MOVLB  00
00B0:  MOVF   22,W
00B1:  CALL   01B
00B2:  MOVWF  25
00B3:  MOVWF  26
00B4:  CLRF   27
00B5:  MOVLW  01
00B6:  MOVWF  29
00B7:  CLRF   28
00B8:  CALL   049
00B9:  MOVF   25,W
00BA:  MOVWF  26
00BB:  CLRF   27
00BC:  CLRF   29
00BD:  MOVLW  80
00BE:  MOVWF  28
00BF:  CALL   049
....................       delay_us(100); // asegurar estabilidad
00C0:  MOVLW  21
00C1:  MOVWF  77
00C2:  DECFSZ 77,F
00C3:  GOTO   0C2
.................... 
....................       // Leemos columnas
....................       for(c = 0; c < 3; c++) {
00C4:  CLRF   23
00C5:  MOVF   23,W
00C6:  SUBLW  02
00C7:  BTFSS  03.0
00C8:  GOTO   145
....................          
....................          if(!input(pines_col[c])) { // columna detectada en 0 --> tecla presionada
00C9:  MOVF   23,W
00CA:  CALL   020
00CB:  MOVWF  25
00CC:  MOVWF  26
00CD:  MOVLW  01
00CE:  MOVWF  27
00CF:  CLRF   29
00D0:  MOVLW  80
00D1:  MOVWF  28
00D2:  CALL   049
00D3:  MOVF   25,W
00D4:  MOVWF  26
00D5:  CLRF   28
00D6:  CLRF   27
00D7:  CALL   069
00D8:  BTFSC  78.0
00D9:  GOTO   143
....................             
....................             delay_ms(20);
00DA:  MOVLW  14
00DB:  MOVWF  25
00DC:  CALL   082
....................             
....................             if(!input(pines_col[c])) { // sigue presionada
00DD:  MOVF   23,W
00DE:  CALL   020
00DF:  MOVWF  25
00E0:  MOVWF  26
00E1:  MOVLW  01
00E2:  MOVWF  27
00E3:  CLRF   29
00E4:  MOVLW  80
00E5:  MOVWF  28
00E6:  CALL   049
00E7:  MOVF   25,W
00E8:  MOVWF  26
00E9:  CLRF   28
00EA:  CLRF   27
00EB:  CALL   069
00EC:  BTFSC  78.0
00ED:  GOTO   143
....................                result = keymap[f][c];
00EE:  MOVF   22,W
00EF:  MOVWF  25
00F0:  MOVLW  03
00F1:  MOVWF  26
*
0116:  MOVF   23,W
0117:  ADDWF  78,W
0118:  CALL   00E
0119:  MOVWF  78
011A:  MOVWF  24
....................                
....................                while(!input(pines_col[c])) {
011B:  MOVF   23,W
011C:  CALL   020
011D:  MOVWF  25
011E:  MOVWF  26
011F:  MOVLW  01
0120:  MOVWF  27
0121:  CLRF   29
0122:  MOVLW  80
0123:  MOVWF  28
0124:  CALL   049
0125:  MOVF   25,W
0126:  MOVWF  26
0127:  CLRF   28
0128:  CLRF   27
0129:  CALL   069
012A:  BTFSC  78.0
012B:  GOTO   130
....................                   delay_ms(10);
012C:  MOVLW  0A
012D:  MOVWF  25
012E:  CALL   082
012F:  GOTO   11B
....................                }
....................                
....................                output_high(pines_filas[f]);
0130:  MOVF   22,W
0131:  CALL   01B
0132:  MOVWF  25
0133:  MOVWF  26
0134:  MOVLW  01
0135:  MOVWF  27
0136:  MOVWF  29
0137:  CLRF   28
0138:  CALL   049
0139:  MOVF   25,W
013A:  MOVWF  26
013B:  CLRF   27
013C:  CLRF   29
013D:  MOVLW  80
013E:  MOVWF  28
013F:  CALL   049
....................                return result;
0140:  MOVF   24,W
0141:  MOVWF  78
0142:  GOTO   149
....................             }
....................          }
0143:  INCF   23,F
0144:  GOTO   0C5
....................       }
0145:  INCF   22,F
0146:  GOTO   09B
....................    }
.................... 
....................    return 'f'; // No se presiono ninguna tecla
0147:  MOVLW  66
0148:  MOVWF  78
0149:  MOVLP  00
014A:  GOTO   1C3 (RETURN)
.................... }
.................... 

Configuration Fuses:
   Word  1: 3F84   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT PLL_SW STVREN BORV19 NODEBUG NOLVP
