CCS PCM C Compiler, Version 5.093, 4770               30-oct-25 14:19

               Filename:   C:\Users\santi\OneDrive\Escritorio\EDI2\TP FINAL\TP_Final_Grupo11.lst

               ROM used:   413 words (10%)
                           Largest free fragment is 2048
               RAM used:   7 (2%) at main() level
                           25 (7%) worst case
               Stack used: 1 locations
               Stack size: 16

0000:  MOVLP  00
0001:  GOTO   16B
0002:  NOP
.................... #include <TP_Final_Grupo11.h>
.................... #include <16F1827.h>
.................... //////////// Standard Header file for the PIC16F1827 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F1827
0003:  BRW
0004:  RETLW  3F
0005:  RETLW  06
0006:  RETLW  5B
0007:  RETLW  4F
0008:  RETLW  66
0009:  RETLW  6D
000A:  RETLW  7D
000B:  RETLW  07
000C:  RETLW  7F
000D:  RETLW  67
000E:  BRW
000F:  RETLW  31
0010:  RETLW  32
0011:  RETLW  33
0012:  RETLW  34
0013:  RETLW  35
0014:  RETLW  36
0015:  RETLW  37
0016:  RETLW  38
0017:  RETLW  39
0018:  RETLW  2A
0019:  RETLW  30
001A:  RETLW  23
001B:  BRW
001C:  RETLW  68
001D:  RETLW  69
001E:  RETLW  6A
001F:  RETLW  6B
0020:  BRW
0021:  RETLW  6C
0022:  RETLW  6E
0023:  RETLW  6F
*
0049:  MOVF   26,W
004A:  ANDLW  07
004B:  MOVWF  77
004C:  RRF    26,W
004D:  MOVWF  78
004E:  RRF    78,F
004F:  RRF    78,F
0050:  MOVLW  1F
0051:  ANDWF  78,F
0052:  MOVF   78,W
0053:  ADDWF  28,W
0054:  MOVWF  04
0055:  MOVLW  00
0056:  ADDWFC 29,W
0057:  MOVWF  05
0058:  CLRF   78
0059:  INCF   78,F
005A:  INCF   77,F
005B:  GOTO   05D
005C:  RLF    78,F
005D:  DECFSZ 77,F
005E:  GOTO   05C
005F:  MOVF   27,F
0060:  BTFSC  03.2
0061:  GOTO   065
0062:  MOVF   78,W
0063:  IORWF  00,F
0064:  GOTO   068
0065:  COMF   78,F
0066:  MOVF   78,W
0067:  ANDWF  00,F
0068:  RETURN
0069:  MOVF   26,W
006A:  ANDLW  07
006B:  MOVWF  77
006C:  RRF    26,W
006D:  MOVWF  78
006E:  RRF    78,F
006F:  RRF    78,F
0070:  MOVLW  1F
0071:  ANDWF  78,F
0072:  MOVF   78,W
0073:  ADDWF  27,W
0074:  MOVWF  04
0075:  MOVLW  00
0076:  ADDWFC 28,W
0077:  MOVWF  05
0078:  MOVF   00,W
0079:  MOVWF  78
007A:  INCF   77,F
007B:  GOTO   07D
007C:  RRF    78,F
007D:  DECFSZ 77,F
007E:  GOTO   07C
007F:  MOVLW  01
0080:  ANDWF  78,F
0081:  RETURN
*
00D5:  CLRF   77
00D6:  CLRF   78
00D7:  MOVF   25,W
00D8:  BCF    03.0
00D9:  BTFSC  26.0
00DA:  ADDWF  77,F
00DB:  RRF    77,F
00DC:  RRF    78,F
00DD:  BTFSC  26.1
00DE:  ADDWF  77,F
00DF:  RRF    77,F
00E0:  RRF    78,F
00E1:  BTFSC  26.2
00E2:  ADDWF  77,F
00E3:  RRF    77,F
00E4:  RRF    78,F
00E5:  BTFSC  26.3
00E6:  ADDWF  77,F
00E7:  RRF    77,F
00E8:  RRF    78,F
00E9:  BTFSC  26.4
00EA:  ADDWF  77,F
00EB:  RRF    77,F
00EC:  RRF    78,F
00ED:  BTFSC  26.5
00EE:  ADDWF  77,F
00EF:  RRF    77,F
00F0:  RRF    78,F
00F1:  BTFSC  26.6
00F2:  ADDWF  77,F
00F3:  RRF    77,F
00F4:  RRF    78,F
00F5:  BTFSC  26.7
00F6:  ADDWF  77,F
00F7:  RRF    77,F
00F8:  RRF    78,F
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #use delay(internal=4MHz)
.................... 
.................... 
.................... 
.................... #use RS232(BAUD = 9600, XMIT = PIN_B5, BITS = 8, PARITY = N, STOP = 1)
*
0109:  MOVLB  01
010A:  BCF    0D.5
010B:  MOVLB  02
010C:  BCF    0D.5
010D:  MOVLW  08
010E:  MOVWF  78
010F:  GOTO   110
0110:  NOP
0111:  BSF    78.7
0112:  GOTO   123
0113:  BCF    78.7
0114:  MOVLB  00
0115:  RRF    22,F
0116:  MOVLB  02
0117:  BTFSC  03.0
0118:  BSF    0D.5
0119:  BTFSS  03.0
011A:  BCF    0D.5
011B:  BSF    78.6
011C:  GOTO   123
011D:  BCF    78.6
011E:  DECFSZ 78,F
011F:  GOTO   114
0120:  GOTO   121
0121:  NOP
0122:  BSF    0D.5
0123:  MOVLW  1B
0124:  MOVWF  04
0125:  DECFSZ 04,F
0126:  GOTO   125
0127:  GOTO   128
0128:  NOP
0129:  BTFSC  78.7
012A:  GOTO   113
012B:  BTFSC  78.6
012C:  GOTO   11D
012D:  MOVLB  00
012E:  RETURN
.................... 
.................... #fuses INTRC_IO   // Oscilador interno con pines RA6 y RA7 como GPIO
.................... #fuses NOMCLR     // Desactivo el MCLR
.................... #fuses NOWDT      // Desactivo el watchdog
.................... 
.................... //CATODO COMUN:
.................... Byte CONST display[10]= {0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x67}; //npn
.................... 
.................... /*****************************************************************************
....................  * Funciones de Inicializacion
....................  ****************************************************************************/
....................  
.................... void Init_GPIO(void);
.................... void Init_Keypad(void);
.................... void decharabin(void);
.................... 
.................... /*****************************************************************************
.................... * Variables globales
.................... ****************************************************************************/
.................... 
.................... const char keymap[4][3] = {
....................   {'1','2','3'},
....................   {'4','5','6'},
....................   {'7','8','9'},
....................   {'*','0','#'}
.................... };
.................... 
.................... char tecla = ' ';
.................... int8 teclabin = 00000000; //inicializo en 0
.................... 
.................... /*****************************************************************************
.................... * Funciones
.................... ****************************************************************************/
.................... 
.................... void maquina(void);
.................... char getKey(void);
.................... 
.................... /*****************************************************************************
.................... * Interrupciones
.................... ****************************************************************************/
.................... 
.................... void main()
*
016B:  MOVLW  6A
016C:  MOVLB  01
016D:  MOVWF  19
016E:  BCF    0D.5
016F:  MOVLB  02
0170:  BSF    0D.5
0171:  MOVLW  20
0172:  MOVLB  00
0173:  MOVWF  20
0174:  CLRF   21
0175:  MOVLB  03
0176:  CLRF   0C
0177:  CLRF   0D
0178:  MOVLB  02
0179:  CLRF   12
017A:  CLRF   11
017B:  CLRF   14
017C:  CLRF   13
.................... {
....................    Init_GPIO();
017D:  MOVLB  00
017E:  GOTO   024
....................    Init_Keypad();
017F:  GOTO   02E
....................    
....................    while(TRUE)
....................    {
.................... 
....................    tecla = getKey();
0180:  GOTO   082
0181:  MOVF   78,W
0182:  MOVWF  20
....................    
....................    if(tecla != 'f') {
0183:  MOVF   20,W
0184:  SUBLW  66
0185:  BTFSC  03.2
0186:  GOTO   19B
....................          printf("<%c>", tecla);
0187:  MOVLW  3C
0188:  MOVWF  22
0189:  CALL   109
018A:  MOVF   20,W
018B:  MOVWF  22
018C:  CALL   109
018D:  MOVLW  3E
018E:  MOVWF  22
018F:  CALL   109
....................          decharabin();
0190:  GOTO   12F
....................          output_a(display[teclabin]);
0191:  MOVF   21,W
0192:  CALL   003
0193:  MOVWF  22
0194:  MOVLB  01
0195:  CLRF   0C
0196:  MOVLB  00
0197:  MOVF   22,W
0198:  MOVLB  02
0199:  MOVWF  0C
019A:  MOVLB  00
....................       } 
019B:  GOTO   180
....................    }
.................... }
.................... 
019C:  SLEEP
.................... void decharabin(){//funcion que cambia de char a binario
....................    if(tecla == '0')
*
012F:  MOVF   20,W
0130:  SUBLW  30
0131:  BTFSS  03.2
0132:  GOTO   135
....................       teclabin=  1111110; //escribo el 0
0133:  MOVLW  46
0134:  MOVWF  21
....................    if (tecla == '1')
0135:  MOVF   20,W
0136:  SUBLW  31
0137:  BTFSC  03.2
....................       teclabin=  0110000; //escribo el 1
0138:  CLRF   21
....................    if (tecla == '2')
0139:  MOVF   20,W
013A:  SUBLW  32
013B:  BTFSS  03.2
013C:  GOTO   13F
....................       teclabin=  1101101; //escribo el 2
013D:  MOVLW  2D
013E:  MOVWF  21
....................    if (tecla == '3')
013F:  MOVF   20,W
0140:  SUBLW  33
0141:  BTFSS  03.2
0142:  GOTO   145
....................       teclabin=  1111001; //escribo el 3
0143:  MOVLW  D9
0144:  MOVWF  21
....................    if (tecla == '4')
0145:  MOVF   20,W
0146:  SUBLW  34
0147:  BTFSS  03.2
0148:  GOTO   14B
....................       teclabin=  0110011; //escribo el 4
0149:  MOVLW  09
014A:  MOVWF  21
....................    if (tecla == '5')
014B:  MOVF   20,W
014C:  SUBLW  35
014D:  BTFSS  03.2
014E:  GOTO   151
....................       teclabin=  1011011; //escribo el 5
014F:  MOVLW  43
0150:  MOVWF  21
....................    if (tecla == '6')
0151:  MOVF   20,W
0152:  SUBLW  36
0153:  BTFSS  03.2
0154:  GOTO   157
....................       teclabin=  0011111; //escribo el 6
0155:  MOVLW  49
0156:  MOVWF  21
....................    if (tecla == '7')
0157:  MOVF   20,W
0158:  SUBLW  37
0159:  BTFSS  03.2
015A:  GOTO   15D
....................       teclabin=  1110000; //escribo el 7
015B:  MOVLW  F0
015C:  MOVWF  21
....................    if (tecla == '8')
015D:  MOVF   20,W
015E:  SUBLW  38
015F:  BTFSS  03.2
0160:  GOTO   163
....................       teclabin=  1111111; //escribo el 8
0161:  MOVLW  47
0162:  MOVWF  21
....................    if (tecla == '9')
0163:  MOVF   20,W
0164:  SUBLW  39
0165:  BTFSS  03.2
0166:  GOTO   169
....................       teclabin=  1110011; //escribo el 9
0167:  MOVLW  FB
0168:  MOVWF  21
0169:  MOVLP  00
016A:  GOTO   191 (RETURN)
.................... }
.................... 
.................... void maquina(void) {
.................... }
.................... 
.................... void Init_GPIO(void){ 
....................    
....................    set_tris_a(0b00000000);
*
0024:  MOVLW  00
0025:  MOVLB  01
0026:  MOVWF  0C
....................    set_tris_b(0b11010000); // RB0, RB1, RB2 y RB3 filas del teclado, entrada
0027:  MOVLW  D0
0028:  MOVWF  0D
....................                            // RB4, RB6, RB7 columnas, salidas
....................    
....................    enable_interrupts(GLOBAL);
0029:  MOVLW  C0
002A:  IORWF  0B,F
002B:  MOVLP  00
002C:  MOVLB  00
002D:  GOTO   17F (RETURN)
.................... }
.................... 
.................... void Init_Keypad(void){
....................    
....................    setup_adc_ports(NO_ANALOGS); // desactiva funciones analógicas en los pines si aplica
002E:  MOVLB  01
002F:  BCF    1E.0
0030:  BCF    1E.1
0031:  BCF    1E.2
0032:  MOVLW  00
0033:  MOVLB  03
0034:  MOVWF  0C
0035:  MOVWF  0D
.................... 
....................    // Se dejan las filas inicialmente en HIGH (no activas)
....................    output_high(PIN_B0);
0036:  MOVLB  01
0037:  BCF    0D.0
0038:  MOVLB  02
0039:  BSF    0D.0
....................    output_high(PIN_B1);
003A:  MOVLB  01
003B:  BCF    0D.1
003C:  MOVLB  02
003D:  BSF    0D.1
....................    output_high(PIN_B2);
003E:  MOVLB  01
003F:  BCF    0D.2
0040:  MOVLB  02
0041:  BSF    0D.2
....................    output_high(PIN_B3);
0042:  MOVLB  01
0043:  BCF    0D.3
0044:  MOVLB  02
0045:  BSF    0D.3
0046:  MOVLP  00
0047:  MOVLB  00
0048:  GOTO   180 (RETURN)
.................... }
.................... 
.................... char getKey(void){
*
0082:  MOVLW  30
0083:  MOVWF  24
.................... 
....................    const unsigned char pines_filas[4] = {PIN_B0, PIN_B1, PIN_B2, PIN_B3};
....................    const unsigned char pines_col[3] = {PIN_B4, PIN_B6, PIN_B7};
....................    int f, c;
....................    char result = '0';
....................    
....................    for(f = 0; f < 4; f++) {
0084:  CLRF   22
0085:  MOVF   22,W
0086:  SUBLW  03
0087:  BTFSS  03.0
0088:  GOTO   105
....................       // Poner todas las filas en HIGH
....................       output_high(PIN_B0);
0089:  MOVLB  01
008A:  BCF    0D.0
008B:  MOVLB  02
008C:  BSF    0D.0
....................       output_high(PIN_B1);
008D:  MOVLB  01
008E:  BCF    0D.1
008F:  MOVLB  02
0090:  BSF    0D.1
....................       output_high(PIN_B2);
0091:  MOVLB  01
0092:  BCF    0D.2
0093:  MOVLB  02
0094:  BSF    0D.2
....................       output_high(PIN_B3);
0095:  MOVLB  01
0096:  BCF    0D.3
0097:  MOVLB  02
0098:  BSF    0D.3
.................... 
....................       // Activar la fila r (tirarla a LOW)
....................       output_low(pines_filas[f]);
0099:  MOVLB  00
009A:  MOVF   22,W
009B:  CALL   01B
009C:  MOVWF  25
009D:  MOVWF  26
009E:  CLRF   27
009F:  MOVLW  01
00A0:  MOVWF  29
00A1:  CLRF   28
00A2:  CALL   049
00A3:  MOVF   25,W
00A4:  MOVWF  26
00A5:  CLRF   27
00A6:  CLRF   29
00A7:  MOVLW  80
00A8:  MOVWF  28
00A9:  CALL   049
.................... 
....................       // Leemos columnas
....................       for(c = 0; c < 3; c++) {
00AA:  CLRF   23
00AB:  MOVF   23,W
00AC:  SUBLW  02
00AD:  BTFSS  03.0
00AE:  GOTO   103
....................          if(!input(pines_col[c])) { // columna detectada en 0 --> tecla presionada
00AF:  MOVF   23,W
00B0:  CALL   020
00B1:  MOVWF  25
00B2:  MOVWF  26
00B3:  MOVLW  01
00B4:  MOVWF  27
00B5:  CLRF   29
00B6:  MOVLW  80
00B7:  MOVWF  28
00B8:  CALL   049
00B9:  MOVF   25,W
00BA:  MOVWF  26
00BB:  CLRF   28
00BC:  CLRF   27
00BD:  CALL   069
00BE:  BTFSC  78.0
00BF:  GOTO   101
.................... 
....................             if(!input(pines_col[c])) { // sigue presionada
00C0:  MOVF   23,W
00C1:  CALL   020
00C2:  MOVWF  25
00C3:  MOVWF  26
00C4:  MOVLW  01
00C5:  MOVWF  27
00C6:  CLRF   29
00C7:  MOVLW  80
00C8:  MOVWF  28
00C9:  CALL   049
00CA:  MOVF   25,W
00CB:  MOVWF  26
00CC:  CLRF   28
00CD:  CLRF   27
00CE:  CALL   069
00CF:  BTFSC  78.0
00D0:  GOTO   101
....................                result = keymap[f][c];
00D1:  MOVF   22,W
00D2:  MOVWF  25
00D3:  MOVLW  03
00D4:  MOVWF  26
*
00F9:  MOVF   23,W
00FA:  ADDWF  78,W
00FB:  CALL   00E
00FC:  MOVWF  78
00FD:  MOVWF  24
....................                return result;
00FE:  MOVF   24,W
00FF:  MOVWF  78
0100:  GOTO   107
....................             }
....................          }
0101:  INCF   23,F
0102:  GOTO   0AB
....................       }
0103:  INCF   22,F
0104:  GOTO   085
....................    }
.................... 
....................    return 'f'; // No se presiono ninguna tecla
0105:  MOVLW  66
0106:  MOVWF  78
0107:  MOVLP  00
0108:  GOTO   181 (RETURN)
.................... }
.................... 

Configuration Fuses:
   Word  1: 3F84   INTRC_IO NOWDT PUT NOMCLR NOPROTECT NOCPD BROWNOUT NOCLKOUT IESO FCMEN
   Word  2: 1EFF   NOWRT PLL_SW STVREN BORV19 NODEBUG NOLVP
